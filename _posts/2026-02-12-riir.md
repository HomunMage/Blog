---
title:  "\"Rewrite It in Rust\" Was a Joke. Then It Happened."
date:   2026-02-12 10:00:00 +0800
tags: [Programming]
---


For years, "Rewrite It in Rust" was the internet's favorite punching bag. The Rust community had earned a reputation: every time someone mentioned a performance issue, a memory bug, or really any problem at all, some Rust enthusiast would appear and suggest — with absolute sincerity — that the solution was to rewrite it in Rust.

It became a meme. Then a joke. Then an insult. Reddit threads mocked the Rust evangelists. "Nobody has the resources to rewrite everything." "Even if they did, nobody would use it." "The Rust community is the most annoying community in programming."

There was another favorite line of dismissal, often attributed to Bjarne Stroustrup himself: "There are only two kinds of languages — the ones people complain about and the ones nobody uses." The implication was clear. C++ may be ugly, bloated, and dangerous — but it runs the world. Rust may be elegant, safe, and beloved by its users — but it's a niche hobby language that nobody actually ships production code in.

It was a clever line. It was also the last comfort of a paradigm that was already being dismantled.

The critics were right about one thing: nobody was going to rewrite their applications in Rust.

They were wrong about everything else. Because while they were busy quoting Stroustrup, Rust had already infiltrated the software beneath their feet — and most of them hadn't noticed.

## What Everyone Expected vs. What Actually Happened

The conventional wisdom assumed Rust would follow the traditional language war playbook: compete head-to-head with C++, Go, and Java for application developers. The battlefield would look like this — Python vs. Go vs. Node vs. Rust vs. PHP — and developers would pick sides, rewrite their backends, and argue about it on Hacker News for a decade.

That's not what happened. Instead:

- You run `uv pip install` — that's Rust underneath.
- Your Python linter is Ruff — Rust.
- Your JS bundler uses SWC — Rust.
- Deno's runtime — Rust.
- You query data with Polars — Rust.
- Pydantic v2's validation core — Rust.

You're still writing Python. You're still writing JavaScript. But the layer beneath you has been quietly replaced. Rust didn't ask you to switch languages. It made your existing language 10–100x faster. The rewrite happened — just not where anyone was looking.

## The Trojan Horse Strategy

Rust is not competing for application developers. It's capturing the *infrastructure layer* — the tools, runtimes, compilers, and package managers that every developer depends on but rarely thinks about.

**In Python**, Ruff single-handedly replaced flake8, black, and isort — and runs 10–100x faster. uv makes pip feel like dial-up. Polars is challenging pandas. HuggingFace's tokenizers run on Rust. The cryptography package is Rust. You keep writing Python. You just do it on a Rust engine.

**In JavaScript/TypeScript**, SWC replaced Babel. Turbopack, Biome, Rspack, Rolldown (Vite's next-gen bundler), Lightning CSS, OXC — all Rust. You keep writing TypeScript. Your entire toolchain is Rust.

**In your terminal**, Warp, Alacritty, Starship, ripgrep, bat, fd, eza — many developers have already switched to all-Rust CLI tools without ever thinking of it that way.

**In your editor**, Zed is written entirely in Rust. VS Code is incorporating Rust modules.

This is the same strategy C used decades ago. Nobody "chose" to use C. But the Linux kernel, CPython, Node's V8, and most databases were all written in C. Everyone was using C all along — they just didn't know it. Rust is running the exact same playbook, one layer up.

The leverage is extraordinary. One team rewrites a package manager in Rust, and millions of Python developers become Rust users overnight — without changing a single line of their own code.

## Then the White House Called C++ a National Security Risk

In February 2024, the White House Office of the National Cyber Director (ONCD) dropped a bombshell: a technical report titled *Back to the Building Blocks: A Path Toward Secure and Measurable Software*. The message was blunt — **C and C++ are memory-unsafe languages**, and the technology ecosystem needs to transition away from them.

The report didn't merely identify the problem. It pointed to the solution. Among the languages it highlighted as memory-safe alternatives, **Rust was the most prominent**.

This wasn't a blog post from a Rust enthusiast. This was the United States federal government declaring that the foundational languages of modern infrastructure — the languages behind your operating system, your browser, your database — are a national security risk. The NSA had published similar guidance months prior, and CISA echoed the message.

The data was damning. Microsoft had reported that roughly 70% of their CVEs originate from memory safety issues. Google found that after introducing Rust into Android, memory vulnerabilities in new code dropped off a cliff. The pattern was consistent across every major tech company that published similar analyses.

For large companies already weighing the Rust question, this changed everything. The question shifted from "should we experiment with Rust?" to "can we justify *not* adopting Rust, when the government is calling C++ a liability and future contracts may require memory-safe languages?"

## Why C++ Can't Just Fix Itself

A natural follow-up: if memory safety is the issue, why doesn't C++ simply add safety features?

They've tried. Bjarne Stroustrup himself has been pushing Safe C++ profiles. The community is well aware of the problem. But C++ faces structural barriers that make self-reform nearly impossible.

**Backward compatibility is a trap.** C++'s fundamental promise is that it won't break old code. Decades of existing systems depend on this. Adding borrow-checker-level safety would restrict pointer behavior, breaking code written in the 1990s. Rust was designed with safety from day one; C++ is trying to bolt it on after forty years. These are fundamentally different engineering challenges.

**The standards process is too slow.** C++ evolves through an ISO committee — hundreds of representatives from different companies, voting on proposals, publishing a new standard every three years. Even minor features can take a decade of debate. Pushing through a fundamental memory safety overhaul in this process? It's not going to happen on any timeline that matters.

**Even a new standard wouldn't fix the ecosystem.** Suppose C++29 ships a safe mode. Then what? Boost, Qt, and millions of lines of legacy code don't become safe overnight. You'd still be mixing safe and unsafe code everywhere, with no economic incentive to migrate systems that already work.

**The big companies did the math and moved on.** Rather than waiting a decade for C++ to maybe produce a half-measure, Google, Microsoft, Amazon, and Cloudflare are writing new infrastructure in Rust today and letting legacy C++ age out gradually. After the White House report, the last reason to bet on C++ reforming itself evaporated.

## Why the Critics Were Looking at the Wrong Scoreboard

The people who laughed at "Rewrite It in Rust" were tracking the wrong metrics. They looked at job postings, Stack Overflow surveys, and how many companies were building backends in Rust. By those measures, Rust was and remains a niche language.

But Rust isn't playing that game.

**They used a "language market share" framework.** Traditional language competition is Java vs. C# vs. Go vs. Rust, all fighting for the same developers. In that model, Rust is tiny. But Rust is competing for infrastructure authors, not application developers. That's a completely different market with completely different dynamics.

**Early rewrites were toys, and first impressions stuck.** A few years ago, the Rust ecosystem was full of hobby clones of Unix utilities — cute but useless. People concluded the Rust community just liked reinventing wheels. Then they stopped paying attention. They missed the inflection point where these projects matured from toys into tools like Ruff that are objectively, measurably, undeniably superior to what they replaced.

**The loudest voices were the most satisfied.** The people mocking Rust on social media were generally content with their existing tools. The people maintaining infrastructure in C++, fighting build system nightmares and debugging segfaults at 3 AM, weren't posting on Reddit. They were quietly rewriting their systems in Rust and shipping.

**"Nobody has the resources" was correct — and completely beside the point.** You don't need millions of Rust developers. You need a few hundred exceptional ones building uv, Ruff, SWC, and Polars. Then millions of Python and JavaScript developers adopt those tools organically, without ever "choosing Rust." The leverage ratio is unlike anything in traditional language adoption.

## The LLM Accelerator Nobody Saw Coming

There's one more factor rapidly compounding Rust's advantages: Large Language Models are neutralizing Rust's biggest weakness.

Rust's steepest barrier has always been the learning curve. The borrow checker, lifetimes, and trait system have caused countless developers to abandon the language in their first month. But LLMs change the equation in ways that specifically and disproportionately favor Rust.

**Rust's compiler errors are made for LLMs.** Paste a Rust compiler error into an LLM and you'll get a correct fix almost every time. The errors are detailed, context-rich, and structured. Compare that to C++ template errors — hundreds of lines of incomprehensible noise that confuse humans and AI alike.

**Strict types constrain the solution space.** When an LLM generates Rust code, it either compiles (and is very likely correct) or it fails loudly at compile time. With Python, an LLM can produce code that runs fine but harbors subtle bugs you won't catch until production. Rust's compiler acts as a verification layer for AI-generated code — an involuntary but highly effective code review.

**Rust has more consistent idioms.** C++ has five ways to do the same thing, each reflecting a different decade's conventions. Rust's community has stronger consensus on idiomatic patterns, which means LLM training data is more consistent and outputs are more reliable.

**This creates a compounding flywheel.** LLMs lower Rust's barrier → more people write Rust → more training data → LLMs get better at Rust → the barrier drops further. And the inverse flywheel punishes C++: LLMs produce buggy C++ → developers trust AI-assisted C++ less → C++ development velocity stagnates.

A team that previously needed three to six months to become productive in Rust can now ramp up in weeks. The seniors learn the core mental models; the LLM handles the borrow checker battles. Rust's notorious learning curve — once its fatal flaw — is becoming a historical footnote.

## The Full Map: Where Rust Has Already Won

The scope of Rust's infiltration extends far beyond developer tooling. It's advancing on nearly every front simultaneously.

**Already captured:** Python tooling (uv, Ruff, Polars, Pydantic core, tokenizers), JavaScript tooling (SWC, Turbopack, Biome, Rspack, Rolldown), terminals and CLI (Warp, Alacritty, Starship, ripgrep), editors (Zed), blockchain (Solana, Polkadot/Substrate, StarkNet — this entire sector is Rust-dominated).

**Actively expanding:** AI/ML infrastructure (HuggingFace safetensors, Candle, Burn), next-generation databases (SurrealDB, Qdrant, Meilisearch, TiKV, Databend), cloud infrastructure (AWS Firecracker powering Lambda, Bottlerocket, Cloudflare Workers internals), and embedded systems (Embassy framework, challenging embedded C).

**Next frontiers:** The Linux kernel has officially accepted Rust. Android is actively pushing Rust adoption. Browser engines are being rebuilt (Servo's technology is already in Firefox via Stylo and WebRender). Networking infrastructure is being replaced (Hickory DNS, Google's Quilkin).

The pattern is consistent: Rust penetrates fastest where the existing code is C/C++, performance matters, bugs are expensive, and the maintainers are exhausted by memory safety issues. You don't need to convince millions of end users. You just need to convince the small group of people maintaining the foundations.

## The Joke Landed. Just Not the Way Anyone Expected.

"Rewrite It in Rust" was a joke because it implied the entire world would stop what it was doing and learn a notoriously difficult language to rewrite perfectly functional software.

That was never the plan.

The actual path — whether emergent or intentional — was far more elegant. A few hundred world-class systems programmers rewrote the *infrastructure layer* in Rust. The White House declared the old way a national security risk. LLMs dissolved the learning curve. And millions of developers woke up one morning to find that their Python was faster, their JavaScript tooling was instant, and their terminal was smoother — all running on a language they never chose to adopt.

The people who laughed at "Rewrite It in Rust" were right that it sounded absurd. They just didn't realize the rewrite was already happening beneath their feet.