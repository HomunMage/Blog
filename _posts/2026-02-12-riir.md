---
title:  "\"Rewrite It in Rust\" Was a Joke. Then It Happened."
date:   2026-02-12 10:00:00 +0800
tags: [Programming]
---


For years, "Rewrite It in Rust" was the internet's favorite punching bag. The Rust community had earned a reputation: every time someone mentioned a performance issue, a memory bug, or really any problem at all, some Rust enthusiast would appear and suggest — with absolute sincerity — that the solution was to rewrite it in Rust.

It became a meme. Then a joke. Then an insult. Reddit threads mocked the Rust evangelists. "Nobody has the resources to rewrite everything." "Even if they did, nobody would use it." "The Rust community is the most annoying community in programming."

There was another favorite line of dismissal, often attributed to Bjarne Stroustrup himself: "There are only two kinds of languages — the ones people complain about and the ones nobody uses." The implication was clear. C++ may be ugly, bloated, and dangerous — but it runs the world. Rust may be elegant, safe, and beloved by its users — but it's a niche hobby language that nobody actually ships production code in.

It was a clever line. It was also the last comfort of a paradigm that was already being dismantled.

The critics were right about one thing: nobody was going to rewrite their applications in Rust.

They were wrong about everything else. Because while they were busy quoting Stroustrup, Rust had already infiltrated the software beneath their feet — and most of them hadn't noticed.

## What Everyone Expected vs. What Actually Happened

The conventional wisdom assumed Rust would follow the traditional language war playbook: compete head-to-head with C++, Go, and Java for application developers. The battlefield would look like this — Python vs. Go vs. Node vs. Rust vs. PHP — and developers would pick sides, rewrite their backends, and argue about it on Hacker News for a decade.

That's not what happened. Instead:

- You run `uv pip install` — that's Rust underneath.
- Your Python linter is Ruff — Rust.
- Your JS bundler uses SWC — Rust.
- Deno's runtime — Rust.
- You query data with Polars — Rust.
- Pydantic v2's validation core — Rust.

You're still writing Python. You're still writing JavaScript. But the layer beneath you has been quietly replaced. Rust didn't ask you to switch languages. It made your existing language 10–100x faster. The rewrite happened — just not where anyone was looking.

## The Trojan Horse Strategy

Rust is not competing for application developers. It's capturing the *infrastructure layer* — the tools, runtimes, compilers, and package managers that every developer depends on but rarely thinks about.

**In Python**, Ruff single-handedly replaced flake8, black, and isort — and runs 10–100x faster. uv makes pip feel like dial-up. Polars is challenging pandas. HuggingFace's tokenizers run on Rust. The cryptography package is Rust. You keep writing Python. You just do it on a Rust engine.

**In JavaScript/TypeScript**, SWC replaced Babel. Turbopack, Biome, Rspack, Rolldown (Vite's next-gen bundler), Lightning CSS, OXC — all Rust. You keep writing TypeScript. Your entire toolchain is Rust.

**In your terminal**, Warp, Alacritty, Starship, ripgrep, bat, fd, eza — many developers have already switched to all-Rust CLI tools without ever thinking of it that way.

**In your editor**, Zed is written entirely in Rust. VS Code is incorporating Rust modules.

This is the same strategy C used decades ago. Nobody "chose" to use C. But the Linux kernel, CPython, Node's V8, and most databases were all written in C. Everyone was using C all along — they just didn't know it. Rust is running the exact same playbook, one layer up.

The leverage is extraordinary. One team rewrites a package manager in Rust, and millions of Python developers become Rust users overnight — without changing a single line of their own code.

## Then the White House Called C++ a National Security Risk

In February 2024, the White House Office of the National Cyber Director (ONCD) dropped a bombshell: a technical report titled *Back to the Building Blocks: A Path Toward Secure and Measurable Software*. The message was blunt — **C and C++ are memory-unsafe languages**, and the technology ecosystem needs to transition away from them.

The report didn't merely identify the problem. It pointed to the solution. Among the languages it highlighted as memory-safe alternatives, **Rust was the most prominent**.

This wasn't a blog post from a Rust enthusiast. This was the United States federal government declaring that the foundational languages of modern infrastructure — the languages behind your operating system, your browser, your database — are a national security risk. The NSA had published similar guidance months prior, and CISA echoed the message.

The data was damning. Microsoft had reported that roughly 70% of their CVEs originate from memory safety issues. Google found that after introducing Rust into Android, memory vulnerabilities in new code dropped off a cliff. The pattern was consistent across every major tech company that published similar analyses.

For large companies already weighing the Rust question, this changed everything. The question shifted from "should we experiment with Rust?" to "can we justify *not* adopting Rust, when the government is calling C++ a liability and future contracts may require memory-safe languages?"

## Why C++ Can't Just Fix Itself

A natural follow-up: if memory safety is the issue, why doesn't C++ simply add safety features?

They've tried. Bjarne Stroustrup himself has been pushing Safe C++ profiles. The community is well aware of the problem. But C++ faces structural barriers that make self-reform nearly impossible.

**Backward compatibility is a trap.** C++'s fundamental promise is that it won't break old code. Decades of existing systems depend on this. Adding borrow-checker-level safety would restrict pointer behavior, breaking code written in the 1990s. Rust was designed with safety from day one; C++ is trying to bolt it on after forty years. These are fundamentally different engineering challenges.

**The standards process is too slow.** C++ evolves through an ISO committee — hundreds of representatives from different companies, voting on proposals, publishing a new standard every three years. Even minor features can take a decade of debate. Pushing through a fundamental memory safety overhaul in this process? It's not going to happen on any timeline that matters.

**Even a new standard wouldn't fix the ecosystem.** Suppose C++29 ships a safe mode. Then what? Boost, Qt, and millions of lines of legacy code don't become safe overnight. You'd still be mixing safe and unsafe code everywhere, with no economic incentive to migrate systems that already work.

**The big companies did the math and moved on.** Rather than waiting a decade for C++ to maybe produce a half-measure, Google, Microsoft, Amazon, and Cloudflare are writing new infrastructure in Rust today and letting legacy C++ age out gradually. After the White House report, the last reason to bet on C++ reforming itself evaporated.

## Why the Critics Missed It

The people who laughed at "Rewrite It in Rust" were tracking the wrong metrics — job postings, Stack Overflow surveys, how many companies were building backends in Rust. By those measures, Rust is indeed niche. But Rust isn't competing for application developers. It's competing for infrastructure authors. That's a completely different market.

Early Rust rewrites *were* toys — hobby clones of `ls` and `cat` that nobody needed. People formed the impression that the Rust community just liked reinventing wheels, and stopped paying attention. They missed the moment those projects matured from curiosities into tools like Ruff that are objectively, undeniably superior to the incumbents.

And the "nobody has the resources" argument was technically correct — and completely beside the point. You don't need millions of Rust developers. You need a few hundred exceptional ones building uv, Ruff, SWC, and Polars. Then millions of Python and JavaScript developers adopt those tools organically, without ever "choosing Rust."

## The LLM Accelerator

One more factor is compounding all of this: Large Language Models are neutralizing Rust's biggest weakness — the learning curve.

Rust's borrow checker and lifetime system have caused countless developers to give up within weeks. But LLMs change the equation in ways that specifically favor Rust. The compiler errors are detailed and structured — paste one into an LLM and you get a correct fix almost every time. The strict type system constrains the solution space, so LLM-generated Rust code that compiles is very likely correct, unlike Python where AI can produce code that runs but harbors subtle bugs. And Rust's community has stronger consensus on idiomatic patterns than C++, making training data more consistent.

This creates a flywheel: LLMs lower Rust's barrier → more people write Rust → more training data → LLMs get better at Rust → the barrier drops further. A team that previously needed months to ramp up in Rust can now do it in weeks. Rust's notorious learning curve is becoming a historical footnote.

## You're Already a Rust User

Here's the thing most people haven't realized: if you use Polars, uv, or Ruff, you are already part of the Rust ecosystem. You just didn't sign up for it.

You didn't need to learn Rust. You didn't need to choose Rust. You chose "the faster tool" or "the better linter," and Rust came along for the ride. But your usage is doing more for Rust's expansion than any conference talk or blog post ever could.

Every time you run `uv pip install`, you're proving market demand. When Ruff's downloads surpass flake8's, other tool authors notice — "rewriting Python tools in Rust" goes from a risky bet to a validated strategy, and more Rust tools get built. Astral, the company behind uv and Ruff, raised significant funding because user adoption metrics proved the commercial viability — your usage becomes their metrics, their metrics become Rust engineers' salaries.

And every tool you switch to is a one-way door. Once you've used Ruff, you're not going back to flake8. The old tool loses contributors, the new one attracts them. The ecosystem migrates, irreversibly.

This is voting with your feet — the most powerful form of support a language can receive. No evangelism required. No Twitter debates. Just millions of developers choosing better tools, and the Rust runtime spreading beneath the surface like mycelium.

"Rewrite It in Rust" was a joke. The punchline is that you're running Rust right now — and you probably didn't even know it.